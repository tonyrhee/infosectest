---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 다음은 보안 공격 관련 용어에 대한 설명이다. () 안에 들어갈 올바른 용어를 쓰시오.

> 사회공학(Social Engineering)
> 

()은/는 컴퓨터 보안에 있어서, 인간 상호작용의 깊은 신뢰를 바탕으로 사람들을 속여서 정상 보안 절차를 깨뜨리기 위한 비기술적 시스템 침입 수단이다. 사례로는 상대방의 자만심이나 권한을 이용하는 공격 및 도청 등이 있다. 

- 보안 공격 관련 용어 중 사회공학과 그레이웨어는 다음과 같다.
    - 사회공학(Social Engineering)
        - 컴퓨터 보안에 있어서, 인간 상호작용의 **깊은 신뢰를 바탕**으로 사람들을 속여서 정상 보안 절차를 깨뜨리기 위한 **비기술적 시스템 침입 수단**
        - 사례로는 상대방의 자만심이나 권한을 이용하는 공격 및 도청 등이 있음
    - 그레이웨어(Grayware)
        - 바이러스나 명백한 악성 코드를 포함하지 않는 **합법적 프로그램**이면서도 **사용자를 귀찮게** 하거나 위험한 상황에 빠뜨릴 수 있는 프로그램
        - 평범한 소프트웨어인지, 바이러스인지 구분하기 어려운 중간 영역에 존재하는 프로그램으로 스파이웨어, 애드웨어, 장난 프로그램, 원격 액세스 도구 등 사용자가 원하지 않는 프로그램을 총칭하는 이름

---

Q. 다음은 IT와 기간산업의 융합, IoT 확산과 함께 점차 발전하는 기술에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 스마트 그리드(Smart Grid)
> 

()은/는 전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용 효율을 극대화하는 전력망이다.

- 신기술 용어 중에서 스마트 그리드와 Wi-SUN의 개념은 다음과 같다.
    - 스마트 그리드(Smart Grid)
        - 전기 및 정보통신기술을 활용하여 **전력망을 지능화, 고도화**함으로써 **고품질의 전력서비스**를 제공하고 에너지 이용 효율을 극대화하는 전력망
    - Wi-SUN(Wireless Smart Utility Network)
        - IEEE 802.15.4g 표준에 기반을 둔 기술로, 900MHz 대역을 활용한 **장거리 무선 통신 기술**로 **스마트 그리드와 연계**하여 **전기, 수도, 가스** 등의 공급자가 무선 네트워크를 이용하여 에너지를 효율적으로 관리할 수 있도록 특화된 무선 통신 기술

---

Q. 다음은 재사용의 유형이다. () 안에 들어갈 유형을 쓰시오.

> 재공학, 재개발
> 
- ( ① )
    - 기존 소프트웨어를 버리지 않고 기능을 개선시키거나 기능을 새로운 소프트웨어로 재활용하는 소프트웨어 재사용 기법
    - 장점으로는 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세의 오류억제가 있음
- ( ② )
    - 기존 시스템 내용을 참조하여 완전히 새로운 시스템을 개발, 기존 시스템에 새로운 기능을 추가, 기존 시스템의 기능을 변경하는 기법

- 재사용의 종류에는 단위 모듈의 재사용의 개념이 확장된 재공학, 역공학, 재개발 기법이 존재한다.
    - 재공학
        - 기존 소프트웨어를 버리지 않고 기능을 개선시키거나 기능을 새로운 소프트웨어로 재활용하는 소프트웨어 재사용 기법
        - 재공학의 장점으로는 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세의 오류 억제가 있음
    - 역공학
        - SW에 대한 디버깅, 디컴파일 등의 분석을 통해 기존 제품에 구현된 구조, 원리, 기술, 알고리즘 등을 역으로 분석하여 재구성하는 기법
    - 재개발
        - 기존 시스템 내용을 참조하여 완전히 새로운 시스템을 개발, 기존 시스템에 새로운 기능을 추가, 기존 시스템의 기능을 변경하는 기법

---

Q. 다음은 형상 관리 도구의 기능에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 체크인(Check-In), 체크아웃(Check-Out), 커밋(Commit)
> 
- ( ① ): 개발자가 수정한 소스를 형상 관리 저장소로 업로드하는 기능
- ( ② ): 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드받는 기능
- ( ③ ): 개발자가 소스를 형상 관리 저장소에 업로드 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에서 반응하도록 하는 기능

- 형상 관리 도구의 기능은 체크인, 체크아웃, 커밋이 있다.
    - 체크인(Check-In)
        - 개발자가 수정한 소스를 형상 관리 저장소로 업로드하는 기능
    - 체크아웃(Check-Out)
        - 형상 관리 저장소로부터 최신 버전을 개발자 PC로 다운로드받는 기능
    - 커밋(Commit)
        - 개발자가 소스를 형상 관리 저장소에 업로드 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에서 반영하도록 하는 기능

---

Q. 다음은 [학생] 테이블 스키마에 대한 명세이다. 학번이라는 컬럼에 대해 인덱스를 생성하려고 한다. ‘학번 인덱스’라는 이름의 인덱스를 생성하는 쿼리를 작성하시오.

```sql
CREATE INDEX 학번 인덱스 ON 학생(학번);
```

- CREATE INDEX는 인덱스를 생성하는 명령이다.
- UNIQUE는 생략 가능하고, 인덱스 걸린 컬럼에 중복 값을 허용하지 않는다.
- 복수 컬럼을 인덱스로 걸 수 있다.
- CREATE INDEX 문법은 다음과 같다.
    
    ```sql
    CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2, ...);
    ```
    

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> not found 20
> 

```c
#include <stdio.h>
void main() {
	int i;
	int find_num=20;
	int find_flag=0;
	int arr[10];
	
	for(i=0; i<10; i++) {
		arr[i] = i+10;
	}
	
	i=0;
	while(i<10){
		if(arr[i] == find_num) {
			find_flag = 1;
			break;
		}
		i++;
	}
	
	if(find_flag == 0) {
		printf("not found %d", find_num);
	}
	else {
		printf("found %d", arr[i]);
	}
}
```

- for 반복문에서 사용할 정수형 변수 i를 선언한다. 정수형 변수 find_num은 20, find_flag를 0으로 초기화한다. 값을 저장할 정수형 변수 arr 배열을 사이즈 10으로 선언한다.
- for 반복문에서 i 값과 10을 더한 후 arr[i]에 대입한다. i를 0으로 초기화하여 while 반복문에서 i가 10보다 작을 때까지 반복한다. 만약 arr[i]가 find_num인 20과 같으면 find_flag에 1을 대입하고 break 문을 수행한다.
- 다음 반복을 위해 i++을 수행하여 i 값을 1 증가시킨다.
- while 문이 종료되고 if 문에서 find_flag 값이 0인 경우 화면에 “not found”를 출력하고 find_num을 출력한다. 그렇지 않을 경우 “found”를 출력하고 arr[i] 값을 출력한다.

| i | arr[i] |
| --- | --- |
| 0 | 10 |
| 1 | 11 |
| 2 | 12 |
| 3 | 13 |
| 4 | 14 |
| 5 | 15 |
| 6 | 16 |
| 7 | 17 |
| 8 | 18 |
| 9 | 19 |

---

Q. 인터페이스의 동작이 잘 진행되는지 지속적으로 확인하기 위해서는 애플리케이션 모니터링 툴(APM; Application Performance Management)을 사용하여 동작 상태를 감시할 수 있다. 대표적인 도구인 ()은/는 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈 소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공한다. () 안에 들어갈 용어를 쓰시오.

> SCOUTER
> 

- 인터페이스 감시 도구는 다음과 같다.
    
    
    | 도구 | 설명 |
    | --- | --- |
    | 스카우터(SCOUTER) | 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈 소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공 |
    | 제니퍼(Jennifer) | 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계 동안 성능을 모니터링하고 분석해주는 APM 소프트웨어 |

---

Q. 데이터베이스 암호화 중 암∙복호화 모듈이 DB 서버에 설치된 방식으로, DB 서버에 암∙복호화, 정책 관리, 키 관리 등의 부하를 발생하는 특징을 가진 방식은 무엇인가?

> 플러그인(Plug-in) 방식
> 

- 데이터베이스 암호화 기법은 다음과 같다.
    - API 방식
        - 애플리케이션 레벨에서 암호 모듈(API)을 적용하는 애플리케이션 수정 방식
        - 애플리케이션 서버에 암∙복호화, 정책 관리, 키 관리 등의 부하 발생
    - Plug-in 방식
        - 암∙복호화 모듈이 DB에 설치된 방식
        - DB 서버에 암∙복호화, 정책관리, 키 관리 등의 부하 발생
    - TDE 방식
        - DB 서버의 DBMS 커널이 자체적으로 암∙복호화 기능을 수행하는 방식
        - 내장되어있는 암호화 기능(TDE: Transparent Data Encryption)을 이용
    - Hybrid 방식
        - API 방식과 Plug-In 방식을 결합하는 방식
        - DB 서버와 애플리케이션 서버로 부하 분산

---

Q. 트랜잭션의 체크포인트(Checkpoint)에 대해서 서술하시오.

> 체크포인트는 ROLLBACK을 위한 시점을 지정하는 트랜잭션 제어언어(TCL)이다.
> 

- 트랜잭션 제어언어는 TCL(Transaction Control Language)이라고 하며, 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어를 지칭한다.
- 트랜잭션 제어언어의 명령어는 다음과 같다. **[커롤체]**
    
    
    | 명령어 | 설명 |
    | --- | --- |
    | 커밋(COMMIT) | 트랜잭션을 메모리에 영구적으로 저장하는 명령어 |
    | 롤백(ROLLBACK) | 트랜잭션 내역을 저장 무효화시키는 명령어 |
    | 체크포인트(CHECKPOINT) | ROLLBACK을 위한 시점을 지정하는 명령어  |

---

Q. 다음은 [점수] 테이블이다. [결과] 테이블처럼 순위를 부여하는 쿼리를 작성하시오.

```sql
SELECT 이름, 수학, DENSE_RANK() OVER (ORDER BY 수학 DESC) AS 등수
FROM 점수
ORDER BY 수학 DESC;
```

[점수]

| 이름 | 수학 |
| --- | --- |
| 두음쌤 | 30 |
| 수제비쌤 | 50 |
| 지기쌤 | 40 |
| 보안쌤 | 50 |

[결과]

| 이름 | 수학 | 등수 |
| --- | --- | --- |
| 수제비쌤 | 50 | 1 |
| 보안쌤 | 50 | 1 |
| 지기쌤 | 40 | 2 |
| 두음쌤 | 30 | 3 |

- 순위 함수에는 RANK, DENSE_RANK, ROW_NUMBER 함수가 있다.
    - RANK
        - 특정 항목(컬럼)에 대한 순위를 구하는 함수
        - 동일 순위의 레코드 존재 시 후순위는 넘어감(2위가 3개인 레코드인 경우: 2위, 2위, 2위, 5위, 6위, …)
    - DENSE_RANK
        - 레코드의 순위를 계산
        - 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음(2위가 3개인 레코드인 경우: 2위, 2위, 2위, 3위, 4위)
    - ROW_NUMBER
        - 레코드의 순위를 계산
        - 동일 순위의 값이 존재해도 이와 무관하게 연속 번호를 부여(2위가 3개인 레코드인 경우: 2위, 3위, 4위, 5위, 6위, …)
- DENSE RANK 문법은 다음과 같다.
    
    ```sql
    SELECT DENSE_RANK(파라미터)
    OVER
    ([PARTITION BY 컬럼1, ...]
    [ORDER BY 컬럼A, ...])
    FROM 테이블명
    ```
    
    - PARTITION BY는 선택 항목이며, 순위를 정할 대상 범위의 컬럼을 설정
        
        PARTITION BY구에는 GROUP BY구가 가진 집약 기능이 없으며, 이로 인해 레코드가 줄어들지 않음
        
    - PARTITION BY를 통해 구분된 레코드 집합을 윈도라고 함
    - 윈도 함수에는 OVER 문구가 필수적으로 포함
    - ORDER BY 뒤에는 SORT 컬럼을 입력(어떤 열을 어떤 순서로 순위를 정할지를 지정)

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> CSSS
> 

```python
i=0
while i < 10:
	i=i+1
	if i % 3 == 0:
		print('S', end='')
	elif i % 5 == 1:
		print('C', end='')
```

- i는 0으로 초기화한다.
- while 문은 i 값이 10보다 작을 때까지 반복한다.
- i=i+1에서 i 값을 1 증가시킨다.
- i 값을 3으로 나눈 나머지가 0이면 화면에 개행 없이 ‘S’를 출력시킨다. end=’’는 개행(줄바꿈)을 하지 않음을 의미한다.
- i 값을 5로 나눈 나머지가 1이면 하면에 개행 없이 ‘C’를 출력시킨다.

| i | i+1 | i%3 | i%5 | print |
| --- | --- | --- | --- | --- |
| 0 | 1 | 1 | 1 | C |
| 1 | 2 | 2 | 2 |  |
| 2 | 3 | 0 | 3 | S |
| 3 | 4 | 1 | 4 |  |
| 4 | 5 | 2 | 0 |  |
| 5 | 6 | 0 | 1 | S |
| 6 | 7 | 1 | 2 |  |
| 7 | 8 | 2 | 3 |  |
| 8 | 9 | 0 | 4 | S |
| 9 | 10 | 1 | 0 |  |

---

Q. 1993년 NSA에서 미 정부 표준으로 지정되었고, DSA(Digital Signature Algorithm)에서 사용하며 160비트의 해시값을 생성하는 해시 알고리즘은 무엇인가?

> SHA-1(Secure Hash Algorithm)
> 

- 해시 암호화 알고리즘은 다음과 같다.
    - MD5(Message-Digest algorithm)
        - 1991년 R.rivest는 MD4를 개선한 암호화 알고리즘으로 프로그램이나 파일의 무결성 검사에 사용
        - 각각의 512bit짜리 입력 메시지 블록에 대해 차례로 동작하여 128bit의 해시값을 생성하는 해시 알고리즘
    - SHA-1(Secure Hash Algorithm)
        - 1993년 NSA에서 미 정부 표준으로 지정되었고, DSA(Digital Signature Algorithm)에서 사용
        - 160bit의 해시값을 생성하는 해시 알고리즘
    - SHA-256/384/512(Secure Hash Algorithm)
        - SHA(Secure Hash Algorithm) 알고리즘의 한 종류로서 256bit의 해시값을 생성하는 해시함수
        - AES(Advanced Encryption Standard, 미연방 표준 알고리즘)의 키 길이인 128, 192, 256bit에 대응하도록 출력 길이를 늘인 알고리즘
    - HAS-160
        - 국내 표준 서명 알고리즘 KCDSA(Korean Certificate-based Digital Signature Algorithm)를 위하여 개발된 해시 함수
        - MD5와 SHA-1의 장점을 취하여 개발된 알고리즘

---

Q. TCP의 대표적인 특징 2가지를 쓰시오.

> 신뢰성 보장 / 연결 지향적 특징 / 흐름 제어(Flow Control) / 혼잡 제어(Congestion Control)
> 

- TCP의 특징은 다음과 같다.
    - 신뢰성 보장
        - 패킷 손실, 중복, 순서 바뀜 등이 없도록 보장
        - TCP 하위 계층인 IP 계층의 신뢰성 없는 서비스를 보완하여 신뢰성 제공
    - 연결 지향적 특징
        - 같은 전송 계층의 UDP가 비연결성인 것과는 달리, TCP는 연결 지향적임
        - 양단 간 애플리케이션/프로세스는 TCP가 제공하는 연결성 회선을 통하여 서로 통신
    - 흐름 제어(Flow Control)
        - 흐름 제어 기능을 활용하여 송신(송신 전송률) 및 수신(수신 처리율) 속도를 일치시킴
    - 혼잡 제어(Congestion Control)
        - 네트워크가 혼잡하다고 판단될 때는 혼잡 제어 기법을 사용하여 송신율을 감속함

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 17
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int[][] n = { {1}, {1,2,3}, {1,2,3,4} };
		int sum=0;
		for(int[] var1 : n) {
			for(int var2 : var1) {
				sum += var2;
			}
		}
		System.out.println(sum);
	}
}
```

- 2차원 정수형 배열 n을 선언과 동시에, 정수형 변수 sum은 선언과 동시에 0으로 초기화한다.
- for 반복문은 2중으로 되어 있고 각 요소의 합계를 계산한다.
- sum 값 17을 화면에 출력한다.

---

Q. 다음 중 [성적] 테이블이 [결과] 테이블과 같도록 쿼리를 작성하시오. (수학 점수에 대해 내림차순으로 정렬하고, 수학 점수가 같을 경우 과학 점수에 대해서 내림차순으로 정렬하시오.)

```sql
SELECT 이름, 수학, 과학
FROM 성적
ORDER BY 수학 DESC, 과학 DESC;
```

```sql
SELECT *
FROM 성적
ORDER BY 수학 DESC, 과학 DESC;
```

[성적]

| 이름 | 수학 | 과학 |
| --- | --- | --- |
| 광종 | 100 | 80 |
| 목종 | 50 | 10 |
| 충렬왕 | 100 | 60 |
| 공민왕 | 50 | 20 |

[결과]

| 이름 | 수학 | 과학 |
| --- | --- | --- |
| 광종 | 100 | 80 |
| 충렬왕 | 100 | 60 |
| 공민왕 | 50 | 20 |
| 목종 | 50 | 10 |

---

Q. 다음은 페이지 교체 기법에 대한 설명이다. () 안에 들어갈 유형을 쓰시오.

> FIFO(First In First Out), LRU(Least Recently Used), LFU(Least Frequently Used)
> 
- ( ① ): 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래있던 페이지를 교체하는 기법
- ( ② ): 사용된 시간을 확인하여 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 기법
- ( ③ ): 사용된 횟수를 확인하여 참조 횟수가 가장 적은 페이지를 선택하여 교체하는 기법

- 페이지 교체 기법 유형은 다음과 같다.
    - FIFO(First In First Out)
        - 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래있던 페이지를 교체하는 기법
    - LRU(Least Recently Used)
        - 사용된 시간을 확인하여 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 기법
        - 프로그램의 지역성의 원리에 따라서 최근에 참조된 페이지는 앞으로도 참조될 가능성이 크고, 최근에 참조되지 않은 페이지는 앞으로도 참조되지 않을 가능성이 크다는 전제로 구현된 알고리즘
    - LFU(Least Frequently Used)
        - 사용된 횟수를 확인하여 참조 횟수가 가장 적은 페이지를 선택하여 교체하는 기법
        - 기억장치에 저장된 페이지 중에서 사용한 횟수가 가장 적은 페이지를 교체하는 알고리즘
    - NUR(Not Used Recently)
        - LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
        - 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 가능성이 크다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
        - 최근의 사용 여부를 확인하기 위해서 페이지마다 참조 비트와 변형 비트 사용
    - OPT(OPTimal Replacement)
        - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
        - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘
    - SCR(Second Chance Replacement)
        - 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법으로 FIFO 기법의 단점을 보완하는 기법

- 지역성이란, **데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것**을 의미한다. 지역성의 전제 조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access하지 않는다는 특성을 기본으로 한다.

---

Q. 다음은 응용 계층 프로토콜에 대한 설명이다. () 안에 들어갈 프로토콜을 쓰시오.

> SMTP(Simple Mail Transfer Protocol), POP3(Post Office Protocol Version 3), IMAP(Internet Messaging Access Protocol)
> 

( ① )은/는 인터넷에서 TCP 포트 번호 25번을 사용하여 이메일을 보내기 위해 이용되는 프로토콜이고, ( ② )은/는 TCP 110번 포트를 사용하고, 응용 계층 인터넷 프로토콜 중 하나로, 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용하는 프로토콜이다. 또한 ( ③ )은/는 TCP 143번 포트를 사용하고, 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오고, 온라인 및 오프라인을 모두 지원하는 프로토콜이다.

- 응용 계층 프로토콜은 다음과 같다.
    - HTTP(HyperText Transfer Protocol)
        - **텍스트 기반의 통신규약**으로 **인터넷에서 데이터를 주고받**을 수 있는 프로토콜
        - **하이퍼텍스트를 빠르게 교환**하기 위한 프로토콜
    - FTP(File Transfer Protocol)
        - TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 **파일**을 전송하기 위한 프로토콜
    - SMTP(Simple Mail Transfer Protocol)
        - 인터넷에서 TCP 포트 번호 25번을 사용하여 **이메일**을 보내기 위해 이용되는 프로토콜
    - POP3(Post Office Protocol Version 3)
        - TCP 110번 포트를 사용하고, 응용 계층 인터넷 프로토콜 중 하나로, **원격 서버**로부터 TCP/IP 연결을 통해 이메일을 가져오는 데 사용하는 프로토콜
    - IMAP(Internet Messaging Access Protocol)
        - TCP 143번 포트를 사용하고, 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오고, **온라인 및 오프라인**을 모두 지원하는 프로토콜
    - Telnet
        - 인터넷이나 로컬 영역에서 **네트워크 연결**에 사용되는 네트워크 프로토콜
    
- 하이퍼텍스트(hypertext)는 **참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트**이다. 주로 컴퓨터나 다른 전자기기들을 통해 표시된다.

---

Q. 클라우드 관련 다양한 기술이 등장하고 있다. 다음이 설명하는 클라우드 기술을 쓰시오.

> 인터클라우드(Inter Cloud), 메타클라우드(Meta Cloud), 멀티클라우드(Multi Cloud)
> 

( ① )은/는 단일 클라우드를 넘어서, 타 클라우드 서비스에서 필요한 자원을 가져다 서비스하는 클라우드 내의 중첩 클라우드 서비스이고, ( ② )은/는 클라우드 서비스를 위한 개발환경, 실행환경, 환경설정 등을 개발자의 요구 조건에 맞게 자유롭게 구성할 수 있도록 제시하는 통합 클라우드 시스템 모델이다. 또한 ( ③ )은/는 2곳 이상의 클라우드 벤더가 제공하는 Public 클라우드를 조합하여 구성하는 클라우드 서비스 제공 모델이다.

- 클라우드 관련 기술은 다음과 같다.
    - 인터클라우드(Inter Cloud)
        - 단일 클라우드를 넘어서, 타 클라우드 서비스에서 필요한 자원을 가져다 서비스하는 클라우드 내의 중첩 클라우드 서비스
    - 메타클라우드(Meta Cloud)
        - 클라우드 서비스를 위한 개발환경, 실행환경, 환경설정 등을 개발자의 요구 조건에 맞게 자유롭게 구성할 수 있도록 제시하는 통합 클라우드 시스템 모델
    - 멀티클라우드(Multi Cloud)
        - 2곳 이상의 클라우드 벤더가 제공하는 Public 클라우드를 조합하여 구성하는 클라우드 서비스 제공 모델

- 벤더(vendor)는 일반적으로 **판매인 또는 판매업자를 가리키는데, 특히 컴퓨터 시스템의 하드웨어나 소프트웨어 제품을 사용자에게 판매하였을 때 그 제품의 브랜드에 대해 책임을 지는 기업을 가리키는 말**, 벤더는 제조업체일 수도 있고 판매 회사일 수도 있다.

---

Q. 다음은 Java 언어 코드이다. 프로그램 실행 결과를 쓰시오.

> 10 5 4 3 2
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int[] arr = {3, 4, 10, 2, 5};
		int temp;
		for(int i=0; i<=3; i++) {
			for(int j=i+1; j<=4; j++) {
				if(arr[i] < arr[j]) {
					temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}	
		}
		for(int i=0; i<5; i++) {
			System.out.print(arr[i] + "");
		}
	}
}
```

- 1차원 정수형 배열 arr을 선언하고 3, 4, 10, 2, 5로 초기화한다.
- 정수형 변수 temp를 선언한다.
- 바깥쪽 for 반복문은 i 값을 0부터 3보다 작거나 같을 때까지 i 값을 1씩 증가시킨다.
- 안쪽 for 반복문은 j 값을 i+1부터 4보다 작거나 같을 때까지 j 값을 1씩 증가시킨다. 만약 arr[i]가 arr[j]보다 작은 경우 두 값을 교환한다.
- 두 값을 교환하기 위해 arr[i] 값을 temp에 대입하고 arr[j]값을 arr[i]에 대입하고 temp 값을 arr[j]에 대입한다.
- 2중 for 반복문은 다음과 같이 동작한다.
    
    
    | i | j | arr[i] | arr[j] | 교환 | arr |
    | --- | --- | --- | --- | --- | --- |
    | 0 | 1 | 3 | 4 | 발생 | 4 3 10 2 5 |
    | 0 | 2 | 4 | 10 | 발생 | 10 3 4 2 5 |
    | 0 | 3 | 10 | 2 |  | 10 3 4 2 5 |
    | 0 | 4 | 10 | 5 |  | 10 3 4 2 5 |
    | 1 | 2 | 3 | 4 | 발생 | 10 4 3 2 5 |
    | 1 | 3 | 4 | 2 |  | 10 4 3 2 5 |
    | 1 | 4 | 4 | 5 | 발생 | 10 5 3 2 4 |
    | 2 | 3 | 3 | 2 |  | 10 5 3 2 4 |
    | 2 | 4 | 3 | 4 | 발생 | 10 5 4 2 3 |
    | 3 | 4 | 2 | 3 | 발생 | 10 5 4 3 2 |
- 아래쪽 for 반복문에서는 i 값을 0부터 5보다 작을 때까지 i 값을 1씩 증가시키며 화면에 arr[i] 값을 공백 한 칸과 같이 출력한다.
```plaintext
Iteration Breakdown:

Initial array: {3, 4, 10, 2, 5}
First outer iteration (i = 0):

Compare arr[0] = 3 with arr[1] = 4: 3 < 4 → Swap
Array becomes: {4, 3, 10, 2, 5}
Compare arr[0] = 4 with arr[2] = 10: 4 < 10 → Swap
Array becomes: {10, 3, 4, 2, 5}
Compare arr[0] = 10 with arr[3] = 2: No swap
Compare arr[0] = 10 with arr[4] = 5: No swap
Second outer iteration (i = 1):

Compare arr[1] = 3 with arr[2] = 4: 3 < 4 → Swap
Array becomes: {10, 4, 3, 2, 5}
Compare arr[1] = 4 with arr[3] = 2: No swap
Compare arr[1] = 4 with arr[4] = 5: 4 < 5 → Swap
Array becomes: {10, 5, 3, 2, 4}
Third outer iteration (i = 2):

Compare arr[2] = 3 with arr[3] = 2: No swap
Compare arr[2] = 3 with arr[4] = 4: 3 < 4 → Swap
Array becomes: {10, 5, 4, 2, 3}
Fourth outer iteration (i = 3):

Compare arr[3] = 2 with arr[4] = 3: 2 < 3 → Swap
Array becomes: {10, 5, 4, 3, 2}
```
**참고 자료**

---

- [https://m.blog.naver.com/gglee0127/221318160003 - RANK, DENSE_RANK, ROW_NUMBER](https://m.blog.naver.com/gglee0127/221318160003)
- [https://ko.wikipedia.org/wiki/다이제스트_(암호학) - MD5](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%9D%B4%EC%A0%9C%EC%8A%A4%ED%8A%B8_(%EC%95%94%ED%98%B8%ED%95%99))
- [https://blog.skby.net/지역성-locality/ - 지역성](https://blog.skby.net/%EC%A7%80%EC%97%AD%EC%84%B1-locality/)
